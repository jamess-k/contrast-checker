import {
  __publicField
} from "./chunk-JVWSFFO4.js";

// node_modules/@smockle/contrast/dist/lib/eightbit.js
var inspect = Symbol.for("nodejs.util.inspect.custom");
var EightBit = class {
  constructor(value) {
    /** A number between 0 and 255. */
    __publicField(this, "value");
    this.value = Number(value);
  }
  /** Returns the current value, e.g. 255. */
  valueOf() {
    return this.value;
  }
  /** Returns a formatted representation of the current value, e.g. "EightBit(255)". */
  [inspect]() {
    return `EightBit(${this.value})`;
  }
  /** Convert from sRGB to linear RGB. */
  linearize() {
    const SCALE = 255;
    const value = this.value / SCALE;
    return value <= 0.03928 ? value / 12.92 : Math.pow((value + 0.055) / 1.055, 2.4);
  }
  /** Returns a Hex with the current value, e.g. Hex("#FF"). */
  toHex() {
    const value = this.value.toString(16).toUpperCase();
    return new Hex(`#${value}`);
  }
};

// node_modules/@smockle/contrast/dist/lib/hex.js
var inspect2 = Symbol.for("nodejs.util.inspect.custom");
function padStart(string, targetLength, padString) {
  if (string.toString().length >= targetLength) {
    return string;
  }
  return padStart(padString.concat(string), targetLength, padString);
}
var Hex = class {
  constructor(value) {
    /** The string representation of a hexadecimal value between 0 ("00") and 255 ("FF"). */
    __publicField(this, "value");
    this.value = value ? padStart(String(value).replace("#", "").toUpperCase(), 2, "0") : null;
  }
  /** Returns the current value, e.g. "FF". */
  valueOf() {
    return this.value;
  }
  /** Returns a formatted representation of the current value, e.g. "#FF". */
  [inspect2]() {
    return `#${this.value}`;
  }
  /** Returns an EightBit with the current value, e.g. EightBit(255). */
  toEightBit() {
    const value = typeof this.value === "string" ? parseInt(this.value, 16) : null;
    return new EightBit(value);
  }
};

// node_modules/@smockle/contrast/dist/lib/eightbitcolor.js
var inspect3 = Symbol.for("nodejs.util.inspect.custom");
var EightBitColor = class {
  constructor(R, G, B) {
    /** The current red value, e.g. EightBit(255). */
    __publicField(this, "R");
    /** The current green value, e.g. EightBit(255). */
    __publicField(this, "G");
    /** The current blue value, e.g. EightBit(255). */
    __publicField(this, "B");
    this.R = new EightBit(R);
    this.G = new EightBit(G);
    this.B = new EightBit(B);
  }
  /** Returns the current red, green and blue values, e.g. { R: 255, G: 255, B: 255 }. */
  valueOf() {
    const R = this.R.valueOf();
    const G = this.G.valueOf();
    const B = this.B.valueOf();
    return { R, G, B };
  }
  /** Returns a formatted representation of the current rgb value, e.g. "rgb(255, 255, 255)". */
  [inspect3]() {
    const R = this.R.valueOf();
    const G = this.G.valueOf();
    const B = this.B.valueOf();
    return `rgb(${R}, ${G}, ${B})`;
  }
  /** Returns the luminosity. */
  luminosity() {
    const R_COEFFICIENT = 0.2126;
    const G_COEFFICIENT = 0.7152;
    const B_COEFFICIENT = 0.0722;
    const R = this.R.linearize();
    const G = this.G.linearize();
    const B = this.B.linearize();
    return R_COEFFICIENT * R + G_COEFFICIENT * G + B_COEFFICIENT * B;
  }
  /** Returns a HexColor with the current value, e.g. Hex("#FFFFFF"). */
  toHexColor() {
    const R = this.R.toHex().valueOf();
    const G = this.G.toHex().valueOf();
    const B = this.B.toHex().valueOf();
    return new HexColor(`#${R}${G}${B}`);
  }
};

// node_modules/@smockle/contrast/dist/lib/hexcolor.js
var inspect4 = Symbol.for("nodejs.util.inspect.custom");
var HexColor = class {
  constructor(value) {
    /** The string representation of a hexadecimal value between 0 ("00") and 255 ("FF"). */
    __publicField(this, "value");
    /** The current red value, e.g. "#FF". */
    __publicField(this, "R");
    /** The current green value, e.g. "#FF". */
    __publicField(this, "G");
    /** The current blue value, e.g. "#FF". */
    __publicField(this, "B");
    this.value = (() => {
      if (!value) {
        return null;
      }
      const _value = (() => {
        switch (true) {
          case String(value).toLowerCase() === "black":
            return "000000";
          case String(value).toLowerCase() === "white":
            return "FFFFFF";
          default:
            return String(value).replace("#", "");
        }
      })();
      switch (_value.length) {
        case 2:
          return `${_value}${_value}${_value}`;
        case 3:
          return `${_value[0]}${_value[0]}${_value[1]}${_value[1]}${_value[2]}${_value[2]}`;
        default:
          return _value;
      }
    })();
    this.R = this.value ? new Hex(this.value.substr(0, 2)) : null;
    this.G = this.value ? new Hex(this.value.substr(2, 2)) : null;
    this.B = this.value ? new Hex(this.value.substr(4, 2)) : null;
  }
  /** Returns the current value, e.g. "FF". */
  valueOf() {
    return this.value;
  }
  /** Returns a formatted representation of the current value, e.g. "#FF". */
  [inspect4]() {
    return `#${this.value}`;
  }
  /** Returns an EightBit with the current value, e.g. { R: 255, G: 255, B: 255 }. */
  toEightBitColor() {
    const R = this.R ? this.R.toEightBit().valueOf() : null;
    const G = this.G ? this.G.toEightBit().valueOf() : null;
    const B = this.B ? this.B.toEightBit().valueOf() : null;
    return new EightBitColor(R, G, B);
  }
};

// node_modules/@smockle/contrast/dist/lib/contrast.js
var inspect5 = Symbol.for("nodejs.util.inspect.custom");
var Contrast = class {
  constructor(foreground, background) {
    /** The foreground color, e.g. "#FFFFFF". */
    __publicField(this, "foreground");
    /** The background color, e.g. "#FFFFFF". */
    __publicField(this, "background");
    /** The luminosity contrast ratio, e.g. 4.5. */
    __publicField(this, "value");
    this.foreground = new HexColor(foreground);
    this.background = new HexColor(background);
    this.value = (() => {
      const foreground2 = this.foreground.toEightBitColor().luminosity();
      const background2 = this.background.toEightBitColor().luminosity();
      const L1 = Math.max(foreground2, background2);
      const L2 = Math.min(foreground2, background2);
      const OFFSET = 0.05;
      return (L1 + OFFSET) / (L2 + OFFSET);
    })();
  }
  /** Returns the luminosity contrast ratio. */
  valueOf() {
    return this.value;
  }
  /** Returns a formatted representation of the luminosity contrast ratio, e.g. "4.5:1". */
  [inspect5]() {
    return `${this.value}:1`;
  }
};
export {
  Contrast,
  EightBit,
  EightBitColor,
  Hex,
  HexColor
};
//# sourceMappingURL=@smockle_contrast.js.map
